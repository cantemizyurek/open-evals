---
title: Knowledge Graph
description: Build and transform structured knowledge representations
---

## Overview

The knowledge graph is the foundation of test data generation. It's a structured representation of your domain knowledge with nodes (documents and chunks) and relationships (connections between concepts).

Unlike raw text, a knowledge graph enables:

- Semantic search through embeddings
- Multi-hop reasoning across related chunks
- Understanding of document structure and relationships
- Efficient retrieval for test generation

## Creating a Knowledge Graph

Start with document nodes representing your source content:

```typescript
import { graph, DocumentNode } from '@open-evals/generator'

const documents = [
  new DocumentNode(
    'typescript-basics.md', // Unique identifier
    'TypeScript is a typed...', // Content
    { category: 'tutorial' } // Custom metadata
  ),
  new DocumentNode('advanced-types.md', 'Advanced TypeScript features...', {
    category: 'reference',
  }),
]

const knowledgeGraph = graph(documents)
```

At this point, your graph contains only document nodes. You'll enrich it with transforms.

## Transform Pipeline

Transforms are composable functions that enrich your graph. Chain them together to build sophisticated knowledge representations:

```typescript
import {
  transform,
  chunk,
  embed,
  relationship,
  summarize,
} from '@open-evals/generator'
import { RecursiveCharacterSplitter } from '@open-evals/rag'
import { openai } from '@ai-sdk/openai'

const enrichedGraph = await transform(graph(documents))
  .pipe(summarize(openai.chat('gpt-4o')))
  .pipe(chunk(new RecursiveCharacterSplitter({ chunkSize: 512 })))
  .pipe(embed(openai.embedding('text-embedding-3-small')))
  .pipe(relationship())
  .apply()
```

Each transform runs sequentially, building on the previous step's output.

## Core Transforms

### chunk

Splits documents into smaller, semantically meaningful pieces:

```typescript
import { chunk } from '@open-evals/generator'
import { RecursiveCharacterSplitter } from '@open-evals/rag'

const graph = await transform(baseGraph)
  .pipe(
    chunk(
      new RecursiveCharacterSplitter({
        chunkSize: 512,
        chunkOverlap: 50,
      })
    )
  )
  .apply()
```

**What it does:** For each document node, creates multiple chunk nodes using the provided text splitter. Maintains parent-child relationships between documents and chunks.

**When to use:** Essential for RAG systems and any scenario where you need granular access to document content. Smaller chunks improve retrieval precision.

### embed

Adds vector embeddings for semantic similarity:

```typescript
import { embed } from '@open-evals/generator'

const graph = await transform(baseGraph)
  .pipe(embed(openai.embedding('text-embedding-3-small')))
  .apply()
```

**What it does:** Generates embeddings for all chunk nodes, storing them in the `embedding` property. Uses the embedding model you provide.

**When to use:** Required for semantic search and relationship detection. Run after chunking so each chunk gets its own embedding.

### relationship

Detects and creates connections between related chunks:

```typescript
import { relationship } from '@open-evals/generator'

const graph = await transform(baseGraph).pipe(relationship(0.7)).apply()
```

**What it does:** Compares chunk embeddings to find semantically similar content. Creates bidirectional relationships between related chunks with similarity scores.

**When to use:** After embedding. Enables multi-hop question generation by connecting related concepts across your knowledge base.

**Configuration:**

- `threshold` (default: 0.7) - Minimum similarity to create a relationship

### summarize

Generates concise summaries of documents:

```typescript
import { summarize } from '@open-evals/generator'

const graph = await transform(baseGraph)
  .pipe(summarize(openai.chat('gpt-4o')))
  .apply()
```

**What it does:** Uses an LLM to generate summaries for each document node, stored in the `summary` property.

**When to use:** Summary is useful for generating personas and synthesizers.

### embedProperty

Creates embeddings for specific node properties:

```typescript
import { embedProperty } from '@open-evals/generator'

const graph = await transform(baseGraph)
  .pipe(summarize(llm))
  .pipe(
    embedProperty(openai.embedding('text-embedding-3-small'), {
      embedProperty: 'summary', // Property to embed
      propertyName: 'summaryEmbedding', // Where to store embedding
      filter: (node) => node.type === 'document',
    })
  )
  .apply()
```

**What it does:** Embeds a specific property instead of the main content. Useful for embedding summaries, titles, or other metadata.

**When to use:** When you want separate embeddings for different aspects of your nodes (e.g., content vs. summary embeddings).

### tap

Inspect or modify the graph mid-pipeline:

```typescript
import { tap } from '@open-evals/generator'

const graph = await transform(baseGraph)
  .pipe(chunk(splitter))
  .pipe(
    tap((g) => {
      console.log(`Created ${g.getNodes().length} nodes`)
      // Optionally modify graph here
    })
  )
  .pipe(embed(embedModel))
  .apply()
```

**What it does:** Allows you to inspect or modify the graph between transforms without breaking the pipeline.

**When to use:** Debugging, logging progress, or applying custom modifications that don't fit into a standard transform.

## Working with the Knowledge Graph

### Querying Nodes

Access nodes by type, property, or custom filter:

```typescript
// Get all documents
const documents = graph.getNodesByType('document')

// Get all chunks
const chunks = graph.getNodesByType('chunk')

// Custom filtering
const tutorials = graph.getNodesBy(
  (node) => node.metadata?.category === 'tutorial'
)

// Get specific node
const node = graph.getNode('chunk-123')
```

### Traversing Relationships

Navigate the graph structure:

```typescript
// Get a node's neighbors
const relatedChunks = graph.getNeighbors('chunk-1')

// Get neighbors of specific type
const similarChunks = graph.getNeighbors('chunk-1', 'similar')

// Traverse the graph with depth limit
for (const node of graph.traverse('doc-1', 2)) {
  console.log(node.id, node.type)
}
```

### Modifying the Graph

Add or remove nodes and relationships programmatically:

```typescript
import { ChunkNode } from '@open-evals/generator'

// Add a new node
const newChunk = new ChunkNode('custom-1', 'Custom content', {})
graph.addNode(newChunk)

// Add a relationship
graph.addRelationship('chunk-1', 'chunk-2', { type: 'similar', score: 0.85 })

// Remove a node (also removes its relationships)
graph.removeNode('chunk-1')
```

## Node Types

### DocumentNode

Represents a source document:

```typescript
import { DocumentNode } from '@open-evals/generator'

const doc = new DocumentNode(
  'my-doc', // ID
  'Content here...', // Text content
  {
    // Custom metadata
    author: 'team',
    version: '2.0',
  }
)

// Access properties
console.log(doc.id) // 'my-doc'
console.log(doc.content) // 'Content here...'
console.log(doc.type) // 'document'
console.log(doc.summary) // Set by summarize transform
```

### ChunkNode

Represents a piece of a document:

```typescript
import { ChunkNode } from '@open-evals/generator'

const chunk = new ChunkNode('chunk-1', 'TypeScript is a typed superset...', {
  documentId: 'typescript-guide',
})

// Access properties
console.log(chunk.embedding) // Set by embed transform
console.log(chunk.relationships) // Map of related nodes
```

## Persistence

Save and load knowledge graphs:

```typescript
import { writeFile, readFile } from 'fs/promises'
import { KnowledgeGraph } from '@open-evals/generator'

// Save to JSON
const json = graph.toJSON()
await writeFile('graph.json', JSON.stringify(json, null, 2))

// Load from JSON
const loaded = await readFile('graph.json', 'utf-8')
const restoredGraph = KnowledgeGraph.fromJSON(JSON.parse(loaded))
```

Saved graphs include all nodes, relationships, embeddings, and metadata - perfect for caching expensive operations.

## Custom Transforms

Create your own transforms for domain-specific enrichment:

```typescript
import type { Transform } from '@open-evals/generator'

// Transform that adds word counts
const addWordCount: Transform = async (graph) => {
  for (const node of graph.getNodes()) {
    const wordCount = node.content.split(/\s+/).length
    node.metadata = {
      ...node.metadata,
      wordCount,
    }
  }
  return graph
}

// Use in pipeline
const graph = await transform(baseGraph)
  .pipe(chunk(splitter))
  .pipe(addWordCount)
  .pipe(embed(embedModel))
  .apply()
```

Transforms receive a knowledge graph and return a knowledge graph (or Promise). They can modify nodes, add relationships, or create new nodes.

## Best Practices

### Order Matters

Run transforms in the right sequence:

```typescript
// Good: summarize before chunking
await transform(graph)
  .pipe(summarize(llm)) // Document-level
  .pipe(chunk(splitter)) // Then split
  .pipe(embed(embedModel)) // Then embed chunks
  .apply()

// Bad: chunking before summarizing loses document context
await transform(graph)
  .pipe(chunk(splitter)) // Splits document
  .pipe(summarize(llm)) // Can't summarize chunks effectively!
  .apply()
```

### Cache Expensive Operations

Save graphs after expensive transforms:

```typescript
// First run - expensive
const graph = await transform(baseGraph)
  .pipe(chunk(splitter))
  .pipe(embed(embedModel))
  .apply()

await writeFile('graph.json', JSON.stringify(graph.toJSON()))

// Later - fast
const cached = KnowledgeGraph.fromJSON(JSON.parse(await readFile('graph.json')))
```
